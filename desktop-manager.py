#!/usr/bin/env python3
# desktop-manager
# Copyright Ryan Brue 2023

VERSION = "0.0.1"


import argparse, os, shutil
from pathlib import Path
from colorama import Fore, Back, Style
import os

SUCCESS = f'[{Fore.GREEN}SUCCESS{Fore.RESET}]'
PROMPT = f'[{Fore.YELLOW}PROMPT{Fore.RESET}]'
NOTICE = f'[{Fore.RED}NOTICE{Fore.RESET}]'
FILE_INPUT = f'[{Fore.BLUE}FILEPATH{Fore.RESET}]'
CONFIGURATION_INPUT = f'[{Fore.BLUE}CONFIG{Fore.RESET}]'
SELECTION_INPUT = f'[{Fore.BLUE}SELECT{Fore.RESET}]'


LOCAL_DESKTOP_APP_PATH = Path.home().joinpath(".local/share/applications/")
DESKTOP_MANAGER_BIN_PATH = Path.home().joinpath(".desktop-manager/")

# Get .desktop string
def populate_desktop_file_string(
        type=None,
        name="Untitled",
        generic_name=None,
        comment=None,
        icon=None,
        exec=None
) -> str:
    ret_str = "[Desktop Entry]\n# Auto-Generated by Desktop Manager. Do not edit unless you know what you are doing!\n"
    ret_str += f'Type={type}\n' if type else "Type=Application\n"
    ret_str += f'Version=1.5\n'
    ret_str += f'Name={name}\n' if name else ""
    ret_str += f'GenericName={generic_name}\n' if generic_name else ""
    ret_str += f'Comment={comment}\n' if comment else ""
    ret_str += f'Icon={icon}\n' if icon else ""
    ret_str += f'Exec={exec}\n' if exec else ""
    return ret_str

def load_from_desktop_file_string(desktop_text: str) -> dict:
    pass

# File actions

def valid_dir(path: str | Path):
    if os.path.isdir(Path(path).expanduser().resolve()):
        return Path(path).expanduser().resolve()
    else:
        raise NotADirectoryError(path)

def valid_file(path: str | Path):
    print(f'Selected {Path(path).expanduser().resolve()}')
    if os.path.isfile(Path(path).expanduser().resolve()):
        return Path(path).expanduser().resolve()
    else:
        raise FileNotFoundError(path)

def make_directory_if_needed(path: Path):
    try:
        os.makedirs(path)
    except:
        print(path,"already exists, continuing...")

def move_file(from_path: Path, to_folder: Path, copy=False):
    src_file = from_path
    dst_file = to_folder.joinpath(src_file.name)
    if copy:
        shutil.copy2(src_file, dst_file)
    else:
        src_file.rename(dst_file)
    return dst_file

def get_installed(name: str):
    installation_dir = DESKTOP_MANAGER_BIN_PATH.joinpath(Path(f'./{name}'))
    # desktop_file = LOCAL_DESKTOP_APP_PATH.joinpath(f'{name}.desktop')
    try:
        valid_dir(installation_dir)
        # valid_file(desktop_file)
        return installation_dir, True
    except:
        return installation_dir, False

def get_desktop_path(name):
    desktop_path = LOCAL_DESKTOP_APP_PATH.joinpath(f'{name}.desktop')
    try:
        valid_file(desktop_path)
        return desktop_path, True
    except:
        return desktop_path, False

# Actions

def install_application(name, exec=None, icon=None, comment=None, delete=True):
    target_folder, exists = get_installed(name)
    desktop_path, exists2 = get_desktop_path(name)
    if exists or exists2:
        print(f'{NOTICE} {name} is already installed. Use desktop-manager.py uninstall {name} to uninstall.')
        return
    
    prompt = input(f'{PROMPT} You are about to install {name} with executable "{exec if exec else "[NONE]"}" and icon "{icon if icon else "[NONE]"}".\nIs this okay? [y/N] ')
    
    if prompt != "y":
        print("Action cancelled by user.")
        return
    
    try:
        make_directory_if_needed(target_folder)
        if exec:
            exec_path = move_file(exec, target_folder, copy=not delete)
        if icon:
            icon_path = move_file(icon, target_folder, copy=not delete)
        
        desktop_file_string = populate_desktop_file_string(
            name=name,
            icon=icon_path,
            exec=exec_path,
            comment=comment
        )
        desktop_path.write_text(desktop_file_string)
        os.system(f'update-desktop-database {LOCAL_DESKTOP_APP_PATH} && desktop-file-validate {desktop_path}')
        print(f'{SUCCESS} {name} is now installed into {target_folder}.')
        
    except Exception as e:
        print("There was a problem (reverting changes):",e)

def basic_install(args):

    print(f'Desktop Manager install wizard v{VERSION}')
    try:
        list_dir()
        exec_path = valid_file(input(f"{FILE_INPUT} Enter filepath for executable: "))
        icon_path = valid_file(input(f"{FILE_INPUT} Enter filepath for icon: "))
    except:
        print(f'{NOTICE} Did not select a file, or selected an invalid file. Quitting...')
        return
    name = input(f"{CONFIGURATION_INPUT} Write the application name: ")
    comment = input(f"{CONFIGURATION_INPUT} Write a description for this application: ")

    delete = input(f"{PROMPT} Delete the files afterwards? [y/N]: ") == "y"

    install_application(name, exec=exec_path, icon=icon_path, comment=comment, delete=delete)

def uninstall_application(name, save_path=None):
    target_folder, exists = get_installed(name)
    if not exists:
        print(f'{NOTICE} {name} is not installed. Quitting...')
        return
    # Move files if save path specified
    if save_path:
        try:
            valid_dir(save_path)
            allfiles = os.listdir(target_folder)
            # iterate on all files to move them to destination folder
            for f in allfiles:
                src_path = os.path.join(target_folder, f)
                dst_path = os.path.join(save_path, f)
                shutil.move(src_path, dst_path)
            shutil.rmtree(target_folder)
        except:
            print(f'{NOTICE} Path {save_path} does not exist, or there was a problem moving files. Quitting...')
            return
    else: # Uninstallation
        shutil.rmtree(target_folder)
    # For both
    desktop_path, valid = get_desktop_path(name)
    if valid:
        desktop_path.unlink()
    print(f'{SUCCESS} Successfully uninstalled {name}.')

def basic_uninstall(args):
    choices = list_installed(None)
    
    user_choice = input(f"{SELECTION_INPUT} Select one of the options above to uninstall (leave blank to cancel): ")

    if user_choice and user_choice in choices:
        select_uninstall_path = input(f"{PROMPT} Delete files associated with this installation? [y/N] ")
        if select_uninstall_path == "y":
            uninstall_application(user_choice)
        else:
            try:
                save_path = valid_dir(input(f"{FILE_INPUT} Select a valid directory to save the files to: "))
            except:
                print(f'{NOTICE} Path {save_path} does not exist. Quitting...')
                return
            uninstall_application(user_choice, save_path)
    else:
        print(f'{NOTICE} Selection canceled, or invalid option. Quitting...')

def basic_update(args):
    return

def list_installed(args):
    choices = os.listdir(DESKTOP_MANAGER_BIN_PATH)
    print(f'Currently installed: {choices}')
    return choices

def list_dir():
    choices = os.listdir(Path.cwd())
    print(f'Files in cwd: {choices}')
    return choices

def no_action(args):
    print("No action specified. Use -h for help.")

parser = argparse.ArgumentParser(
    description="command-line utility to create and manage custom '.desktop' applications in Linux!"
)
parser.set_defaults(func=no_action)
subparsers = parser.add_subparsers(title="actions",description="valid actions",help="sub command help")
###############################
# Actions for Desktop Manager #
###############################
# INSTALL APP COMMAND
basic_install_parser = subparsers.add_parser("install",help="open a basic installation wizard for a single application")
basic_install_parser.set_defaults(func=basic_install)
# UPDATE APP COMMAND
update_parser = subparsers.add_parser("update",help="update the executable or icon of a managed shortcut")
update_parser.set_defaults(func=basic_update)
# UNINSTALL COMMAND
basic_uninstall_parser = subparsers.add_parser("uninstall",help="open a basic uninstall wizard for currently installed applications")
basic_uninstall_parser.set_defaults(func=basic_uninstall)
# LIST COMMAND
list_parser = subparsers.add_parser("list", help="list app shortcuts managed by Desktop Manager")
list_parser.set_defaults(func=list_installed)

args = parser.parse_args()
args.func(args)
